
#include <iostream>
#include "BinaryTree.hpp"
#include "IntTreeInterface.hpp"
#include "FloatTreeInterface.hpp"
#include "TreeInterface.hpp"
#include "Tests.hpp"
// Не работает балансировка - все повороты(малыt ломаются при двойном повороте)
// Возможны одинковые элементы - поправить
int main() {
    




    std::string element_str;
    size_t type;
    size_t size;
    IntTestRun();
    FloatTestRun();
    TreeInterface* new_interface;
    bool programm = true;
    std::cout<<"1.Int tree typed by hands\n2.Float tree by hands\n3.Int tree randomly generated by size\n4.Float tree randomly generated by size\n5.Exit\n"<<std::endl;

    getline(std::cin, element_str);
    type= stoi(element_str);
    switch(type){
        case 1:
            new_interface = new IntTreeInterface();
            break;
        case 2:
            new_interface = new FloatTreeInterface();
            break;
        case 3:
            std::cout<<"Type size of tree"<<std::endl;
            getline(std::cin, element_str);
            size= stoi(element_str);
            new_interface = new IntTreeInterface(size);
        case 4:
            std::cout<<"Type size of tree"<<std::endl;
            getline(std::cin, element_str);
            size= stoi(element_str);
            new_interface = new FloatTreeInterface(size);
        case 5:
            programm = false;
            break;
        default:
            throw MenuError(WrongMenuInput);
    }
    while (programm){
        std::cout<<"1.Add element\n2.Erase element\n3.Tree with condition\n4.Modify tree\n5.Size of tree\n6.Is element here\n7.To string\n8.Subtree\n9.Print tree\n10.Exit\n"<<std::endl;

        getline(std::cin, element_str);
        type= stoi(element_str);
        switch(type){
            case 1:
                new_interface->AddElement();
                break;
            case 2:
                new_interface->EraseElement();
                break;
            case 3:
                new_interface->ToTreeWithCondition();
                break;
            case 4:
                new_interface->ModifyTree();
                break;
            case 5:
                new_interface->SizeOfTree();
                break;
            case 6:
                new_interface->IfElementHere();
                break;
            case 7:
                new_interface->ToString();
                break;
            case 8:
                new_interface->TreeToSubTree();
                break;
            case 9:
                new_interface->Print();
                break;
            case 10:
                programm = false;
                break;
            default:
                throw MenuError(WrongMenuInput);
        }
    }
    

    return 0;
}


